[<< К содержанию](./readme.md)

## Основные команды GIT

### *git add*

Команда `git add` добавляет содержимое рабочей директории в индекс для последующего коммита. По умолчанию команда `git commit` использует только этот индекс, поэтому можно использовать команду `git add` для сборки слепка следующего коммита.

### *git status*

Команда `git status` показывает состояние файлов в рабочей директории:
1. какие файлы изменены, но не добавлены в индекс;
2. какие ожидают коммита в индексе.

Плюс к этому выводятся подсказки, как можно изменить состояние файлов.

### *git diff*

Команда `git diff` используется для вычисления разницы между двумя любыми GIT-деревьями. Например, это может быть разница:
1. между рабочей директорией и индексом: 
```bash hljs=
git diff
```
2. между индексом и последним коммитом: 
```bash hljs=
git diff --staget
```
3. между текущей ветвью и главной:
```bash hljs=
git diff master
```
4. между двумя ветвями, например, основной и промежуточной:
```bash hljs=
git diff master..staging
```
5. показывать только файлы, которые отличаются между двумя ветвями, например, между основной и промежуточной:
```bash hljs=
git diff --name-status master..staging
```

### *git commit*

Команда `git commit` берёт все данные, добавленные в индекс с помощью `git add` и сохраняет их слепок во внутренней базе данных, а потом сдвигает указатель текущей ветки на данный слепок.

### *git reset*

Команда `git reset` используется для отмены изменений. При использовании параметра `--hard` эта команда может изменить файлы в рабочей директории, что при неправильном использовании может привести к потере наработок.

### *git rm*

Команда `git rm` используется для удаления файлов из индекса и рабочей директории.

### *git mv*

Команда `git mv` - удобный способ переместить файл, а затем выполнить `git add` для нового файла и `git rm` - для старого.

### *git clean*

Команда `git clean` используется для удаления мусора из рабочей директории. Например, файлы слияний конфликтов.

### git branch

Команда `git branch` - это своего рода менеджер веток. С её помощь можно:
1. создать новую ветку:
```bash hljs=
git branch <name_of_new_branch>
```
2. перечисление всех существующих веток - `git branch`, где символом `*` будет отмечена ветка, где вы сейчас находитесь:

```bash hljs=
  first_branch
* master
  second_branch
```
3. с помощью параметра `-v` можно получить последний сохранённый коммит в каждой ветке:
```bash hljs=
git branch -v
```
4. переименовать ветку:
```bash hljs=
git branch -m <new_name_of_branch>
```
5. удалить ветку:
```bash hljs=
git branch -d <name of branch>
```
  * **Нельзя удалить веку в которой вы находитесь в данный момент** - GIT выдаст ошибку и не произведёт удаление.
  * **GIT не позволит удалить ветку, в которой есть несохранённые изменения**. В том случае, если вы уверены, что изменения не нужно сохранять и можно удалить, то вместо параметра `-d` нужно использовать параметр `-D`:
  ```bash hljs=
  git branch -D <name_of_branch>
  ```

### *git checkout*

Команда `git checkout` используется для переключения между ветками и выгрузки их содержимого в рабочую директорию.

### *git merge*

Команда `git merge` используется для слияния одной или нескольких веток в текущую. Далее она устанавливает указатель текущей ветки на результирующий коммит.

### *git log*

Команда `git log` используется для просмотра истории коммитов, начиная с самого последнего. По умолчанию она показывает только историю текущей ветки, но может быть настроена на показ истории других веток, даже нескольких сразу. Также её можно использовать для просмотра различий между ветками на уровне коммитов.

### *git tag*

Команда `git tag` используется для создания постоянной метки на какой-либо момент в истории проекта. Обычно применяется для релизов.

### *git fetch*

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет, и сохраняет их локально.

### *git pull*

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`. GIT сначала забирает все изменения из удалённого репозитория, а затем пытается слить их с текущей веткой.

### *git push*

Команда `git push` используется для связи с удалённым репозиторием, вычисления локальных изменений, отсутствующих в нём, и передачи этих изменений в данный репозиторий. Этой команде требуется право на запись в репозиторий, поэтому ей необходима аутентификация.

### *git remote*

Команда `git remote` служит для управления списком удалённы репозиториев. Она позволяет сохранять длинные URL репозиториев в виде коротких строк, например, `origin`. Можно использовать несколько удалённых репозиториев для работы. `git remote` сможет добавлять, изменять и удалять их.
